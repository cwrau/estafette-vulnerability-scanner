package main

import (
	"context"
	"encoding/json"
	"io/ioutil"
	"os"
	"path/filepath"
	"runtime"
	"sync"
	"time"

	"github.com/alecthomas/kingpin"
	foundation "github.com/estafette/estafette-foundation"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/rs/zerolog/log"

	"github.com/ericchiang/k8s"
	corev1 "github.com/ericchiang/k8s/apis/core/v1"
)

var (
	appgroup  string
	app       string
	version   string
	branch    string
	revision  string
	buildDate string
	goVersion = runtime.Version()
)

var (
	nodeName               = kingpin.Flag("node-name", "Node this application runs on.").Envar("NODE_NAME").String()
	stateFileDirectory     = kingpin.Flag("state-file-directory", "Directory the state file is mounted to.").Default("/state").Envar("STATE_FILE_DIRECTORY").String()
	stateFileName          = kingpin.Flag("state-file-name", "Name of the state file.").Default("state.json").Envar("STATE_FILE_NAME").String()
	stateFileConfigmapName = kingpin.Flag("state-file-configmap-name", "Name of the configmap storing the state file.").Envar("STATE_FILE_CONFIGMAP_NAME").String()

	// define prometheus metrics
	detectedVulnerabilities = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Name: "estafette_vulnerability_scanner_detected_vulnerabilities",
			Help: "Vulnerabilities found in scanned images",
		},
		[]string{"image", "severity"},
	)

	scannedImagesTotals = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "estafette_vulnerability_scanner_scanned_images_total",
			Help: "Number of scanned images",
		},
		[]string{"status"},
	)

	purgedImagesTotals = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "estafette_vulnerability_scanner_purged_images_total",
			Help: "Number of purged images",
		},
		[]string{"status"},
	)

	updatedDatabaseTotals = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "estafette_vulnerability_scanner_updated_database_total",
			Help: "Number of database updates",
		},
		[]string{"status"},
	)
)

func init() {
	prometheus.MustRegister(detectedVulnerabilities)
	prometheus.MustRegister(scannedImagesTotals)
	prometheus.MustRegister(purgedImagesTotals)
	prometheus.MustRegister(updatedDatabaseTotals)

	k8s.Register("", "v1", "events", true, &corev1.Event{})
	k8s.RegisterList("", "v1", "events", true, &corev1.EventList{})
}

func main() {

	// parse command line parameters
	kingpin.Parse()

	// init log format from envvar ESTAFETTE_LOG_FORMAT
	foundation.InitLoggingFromEnv(foundation.NewApplicationInfo(appgroup, app, version, branch, revision, buildDate))

	// create context to cancel commands on sigterm
	ctx := foundation.InitCancellationContext(context.Background())

	// create kubernetes api client
	kubeClient, err := k8s.NewInClusterClient()
	if err != nil {
		log.Fatal().Err(err)
	}

	// create vulnerability scanner
	scanner := NewScanner(ctx)

	// start prometheus
	foundation.InitMetrics()

	// define channel used to gracefully shutdown the application
	gracefulShutdown, waitGroup := foundation.InitGracefulShutdownHandling()

	// read state from file
	log.Info().Msgf("Reading state from state file...")
	vulnerabilityReportState, err := readStateFromStateFile()
	if err != nil {
		log.Fatal().Err(err).Msg("Failed reading state from state file")
	}

	go func(waitGroup *sync.WaitGroup) {
		// loop indefinitely
		for {
			// get all pods for all namespaces and extract containers
			var podList corev1.PodList
			if err := kubeClient.List(context.Background(), k8s.AllNamespaces, &podList); err != nil {
				log.Error().Err(err).Msg("Failed listing all pods")
			}

			vulnerabilityReportState = purgeObsoleteState(vulnerabilityReportState, podList.Items)

			vulnerabilityReportState = scanPods(scanner, vulnerabilityReportState, podList.Items, *nodeName, detectedVulnerabilities, scannedImagesTotals, purgedImagesTotals, updatedDatabaseTotals)

			log.Info().Msgf("Writing state to configmap...")
			err = writeStateToConfigmap(kubeClient, vulnerabilityReportState)
			if err != nil {
				log.Fatal().Err(err).Msg("Failed writing state to configmap")
			}

			// sleep random time around 900 seconds
			sleepTime := foundation.ApplyJitter(900)
			log.Info().Msgf("Sleeping for %v seconds...", sleepTime)
			time.Sleep(time.Duration(sleepTime) * time.Second)
		}
	}(waitGroup)

	signalReceived := <-gracefulShutdown
	log.Info().Msgf("Received signal %v. Waiting for running tasks to finish...", signalReceived)

	waitGroup.Wait()

	log.Info().Msgf("Writing state to configmap...")
	err = writeStateToConfigmap(kubeClient, vulnerabilityReportState)
	if err != nil {
		log.Fatal().Err(err).Msg("Failed writing state to configmap")
	}

	log.Info().Msg("Shutting down...")
}

func purgeObsoleteState(vulnerabilityReportState map[string][]VulnerabilityReport, pods []*corev1.Pod) map[string][]VulnerabilityReport {

	images := getUniqueContainerImages(pods)

	for image := range vulnerabilityReportState {
		if !foundation.StringArrayContains(images, image) {
			delete(vulnerabilityReportState, image)
		}
	}

	return vulnerabilityReportState
}

func scanPods(scanner Scanner, vulnerabilityReportState map[string][]VulnerabilityReport, pods []*corev1.Pod, nodeName string, detectedVulnerabilities *prometheus.GaugeVec, scannedImagesTotals, purgedImagesTotals, updatedDatabaseTotals *prometheus.CounterVec) map[string][]VulnerabilityReport {

	// update vulnerability db
	log.Info().Msg("Updating trivy database...")
	err := scanner.UpdateDatabase()
	dbUpdateStatus := "succeeded"
	if err != nil {
		log.Error().Err(err).Msgf("Failed to update trivy database")
		dbUpdateStatus = "failed"
	}
	if updatedDatabaseTotals != nil {
		updatedDatabaseTotals.With(prometheus.Labels{"status": dbUpdateStatus}).Inc()
	}

	// retrieve all used images
	images := getUniqueContainerImages(pods)
	imageUsedOnThisNode := getContainerImagesForCurrentNode(pods, nodeName)

	for _, image := range images {
		// scan each image
		log.Info().Msgf("Scanning container image %v for vulnerabilities...", image)
		vulnerabilityReports, err := scanner.ScanImage(image)
		vulnerabilityReportState[image] = vulnerabilityReports
		scanStatus := "succeeded"
		if err != nil {
			log.Error().Err(err).Msgf("Scanning image %v failed", image)
			scanStatus = "failed"
		}
		if scannedImagesTotals != nil {
			scannedImagesTotals.With(prometheus.Labels{"status": scanStatus}).Inc()
		}

		// set # of vulnerabilities in prometheus metric
		if detectedVulnerabilities != nil {
			// loop all reports and expose them as metrics in order to keep them fresh (prometheus metrics turn stale after 5 minutes)
			for im, vr := range vulnerabilityReportState {
				if len(vr) > 0 {
					groupedReport := groupReportPerLevel(vr)
					for severity, v := range groupedReport {
						detectedVulnerabilities.With(prometheus.Labels{"image": im, "severity": severity}).Set(v)
					}
				} else {
					detectedVulnerabilities.With(prometheus.Labels{"image": im, "severity": ""}).Set(float64(0))
				}
			}
		}

		if len(vulnerabilityReports) > 0 {
			log.Warn().Msgf("Image %v has %v vulnerabilities!", image, len(vulnerabilityReports[0].Vulnerabilities))
		}

		// remove image from this node if it's not needed by any pod, otherwise too many images will end up on the host
		if !foundation.StringArrayContains(imageUsedOnThisNode, image) {
			log.Info().Msgf("Removing container image %v (not needed on this node)...", image)
			err := scanner.RemoveImage(image)
			purgeStatus := "succeeded"
			if err != nil {
				log.Error().Err(err).Msgf("Failed to remove image %v", image)
				purgeStatus = "failed"
			} else {
				log.Info().Msgf("Succesfully remove image %v", image)
			}
			if purgedImagesTotals != nil {
				purgedImagesTotals.With(prometheus.Labels{"status": purgeStatus}).Inc()
			}
		}
	}

	return vulnerabilityReportState
}

func getUniqueContainerImages(pods []*corev1.Pod) (images []string) {

	for _, p := range pods {
		if p != nil {
			if p.Spec != nil {

				// loop InitContainers and collect images
				if p.Spec.InitContainers != nil {
					for _, c := range p.Spec.InitContainers {
						if c != nil {
							image := c.GetImage()
							if image != "" && !foundation.StringArrayContains(images, image) {
								images = append(images, image)
							}
						}
					}
				}

				// loop Containers and collect images
				if p.Spec.Containers != nil {
					for _, c := range p.Spec.Containers {
						if c != nil {
							image := c.GetImage()
							if image != "" && !foundation.StringArrayContains(images, image) {
								images = append(images, image)
							}
						}
					}
				}
			}
		}
	}

	return
}

func getContainerImagesForCurrentNode(pods []*corev1.Pod, nodeName string) (images []string) {

	filteredPods := make([]*corev1.Pod, 0)

	for _, p := range pods {
		if p != nil {
			if p.Spec != nil && p.Spec.NodeName != nil && *p.Spec.NodeName == nodeName {
				filteredPods = append(filteredPods, p)
			}
		}
	}

	images = getUniqueContainerImages(filteredPods)

	return
}

func groupReportPerLevel(vulnerabilityReports []VulnerabilityReport) (groupedReport map[string]float64) {

	groupedReport = map[string]float64{}

	for _, r := range vulnerabilityReports {
		for _, v := range r.Vulnerabilities {
			if val, ok := groupedReport[v.Severity]; ok {
				groupedReport[v.Severity] = val + 1
			} else {
				groupedReport[v.Severity] = 0
			}
		}
	}

	return
}

func readStateFromStateFile() (map[string][]VulnerabilityReport, error) {

	vulnerabilityReportState := map[string][]VulnerabilityReport{}

	stateFilePath := filepath.Join(*stateFileDirectory, *stateFileName)

	// check if state file exists in configmap
	if _, err := os.Stat(stateFilePath); !os.IsNotExist(err) {

		log.Info().Msgf("File %v exists, reading contents...", stateFilePath)

		// read state file
		data, err := ioutil.ReadFile(stateFilePath)
		if err != nil {
			return vulnerabilityReportState, err
		}

		log.Info().Msgf("Unmarshalling file %v contents...", stateFilePath)

		// unmarshal state file
		if err := json.Unmarshal(data, &vulnerabilityReportState); err != nil {
			return vulnerabilityReportState, err
		}
	}

	return vulnerabilityReportState, nil
}

func writeStateToConfigmap(kubeClient *k8s.Client, vulnerabilityReportState map[string][]VulnerabilityReport) error {

	// retrieve configmap
	var configMap corev1.ConfigMap
	err := kubeClient.Get(context.Background(), kubeClient.Namespace, *stateFileConfigmapName, &configMap)
	if err != nil {
		return err
	}

	// marshal state to json
	stateData, err := json.Marshal(vulnerabilityReportState)

	if configMap.Data == nil {
		configMap.Data = make(map[string]string)
	}

	configMap.Data[*stateFileName] = string(stateData)

	// update configmap to have state available when the application runs the next time and for other applications
	err = kubeClient.Update(context.Background(), &configMap)
	if err != nil {
		return err
	}

	log.Info().Msgf("Stored state in configmap %v...", *stateFileConfigmapName)
	return nil
}
