package main

import (
	"context"
	"runtime"
	"sync"
	"time"

	"github.com/alecthomas/kingpin"
	foundation "github.com/estafette/estafette-foundation"
	"github.com/rs/zerolog/log"

	"github.com/ericchiang/k8s"
	corev1 "github.com/ericchiang/k8s/apis/core/v1"
)

var (
	appgroup  string
	app       string
	version   string
	branch    string
	revision  string
	buildDate string
	goVersion = runtime.Version()
)

var (
	nodeName = kingpin.Flag("node-name", "Node this application runs on.").Envar("NODE_NAME").String()
)

func init() {
	k8s.Register("", "v1", "events", true, &corev1.Event{})
	k8s.RegisterList("", "v1", "events", true, &corev1.EventList{})
}

func main() {

	// parse command line parameters
	kingpin.Parse()

	// init log format from envvar ESTAFETTE_LOG_FORMAT
	foundation.InitLoggingFromEnv(foundation.NewApplicationInfo(appgroup, app, version, branch, revision, buildDate))

	// create context to cancel commands on sigterm
	ctx := foundation.InitCancellationContext(context.Background())

	// create kubernetes api client
	kubeClient, err := k8s.NewInClusterClient()
	if err != nil {
		log.Fatal().Err(err)
	}

	// create vulnerability scanner
	scanner := NewScanner(ctx)

	// start prometheus
	foundation.InitMetrics()

	// define channel used to gracefully shutdown the application
	gracefulShutdown, waitGroup := foundation.InitGracefulShutdownHandling()

	go func(waitGroup *sync.WaitGroup) {
		// loop indefinitely
		for {
			// get all pods for all namespaces and extract containers
			var podList corev1.PodList
			if err := kubeClient.List(context.Background(), k8s.AllNamespaces, &podList); err != nil {
				log.Error().Err(err).Msg("Failed listing all pods")
			}

			scanPods(scanner, podList.Items, *nodeName)

			// sleep random time around 900 seconds
			sleepTime := foundation.ApplyJitter(900)
			log.Info().Msgf("Sleeping for %v seconds...", sleepTime)
			time.Sleep(time.Duration(sleepTime) * time.Second)
		}
	}(waitGroup)

	signalReceived := <-gracefulShutdown
	log.Info().
		Msgf("Received signal %v. Waiting for running tasks to finish...", signalReceived)

	waitGroup.Wait()

	log.Info().Msg("Shutting down...")
}

func scanPods(scanner Scanner, pods []*corev1.Pod, nodeName string) {

	scanner.UpdateDatabase()

	images := getUniqueContainerImages(pods)
	imageUsedOnThisNode := getContainerImagesForCurrentNode(pods, nodeName)

	for _, image := range images {
		vulnerabilityReports, err := scanner.ScanImage(image)
		if err != nil {
			log.Error().Err(err).Msgf("Scanning image %v failed", image)
		}
		if len(vulnerabilityReports) > 0 {
			log.Warn().Msgf("Image %v has %v vulnerabilities!", image, len(vulnerabilityReports[0].Vulnerabilities))
		}

		if !foundation.StringArrayContains(imageUsedOnThisNode, image) {
			scanner.RemoveImage(image)
		}
	}
}

func getUniqueContainerImages(pods []*corev1.Pod) (images []string) {

	for _, p := range pods {
		if p != nil {
			if p.Spec != nil {

				// loop InitContainers and collect images
				if p.Spec.InitContainers != nil {
					for _, c := range p.Spec.InitContainers {
						if c != nil {
							image := c.GetImage()
							if image != "" && !foundation.StringArrayContains(images, image) {
								images = append(images, image)
							}
						}
					}
				}

				// loop Containers and collect images
				if p.Spec.Containers != nil {
					for _, c := range p.Spec.Containers {
						if c != nil {
							image := c.GetImage()
							if image != "" && !foundation.StringArrayContains(images, image) {
								images = append(images, image)
							}
						}
					}
				}
			}
		}
	}

	return
}

func getContainerImagesForCurrentNode(pods []*corev1.Pod, nodeName string) (images []string) {

	filteredPods := make([]*corev1.Pod, 0)

	for _, p := range pods {
		if p != nil {
			if p.Spec != nil && p.Spec.NodeName != nil && *p.Spec.NodeName == nodeName {
				filteredPods = append(filteredPods, p)
			}
		}
	}

	images = getUniqueContainerImages(filteredPods)

	return
}
